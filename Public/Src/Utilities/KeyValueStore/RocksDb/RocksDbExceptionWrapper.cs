using System;
using System.Collections.Generic;
using System.Diagnostics.ContractsLight;
using System.Threading;
using RocksDbSharp;

namespace BuildXL.Engine.Cache.KeyValueStores
{
    public partial class KeyValueStoreAccessor : IDisposable
    {
        /// <summary>
        /// This is a class meant to wrap all usages around a RocksDb store in order to separate exceptions that are 
        /// due to our business logic, versus ones that are generated by RocksDb for one reason or another.
        /// </summary>
        private class RocksDbExceptionWrapper : IBuildXLKeyValueStore, IDisposable
        {
            public static object RocksDbInternalExceptionMarker = new object();

            private readonly RocksDbStore m_store;

            /// <nodoc />
            public RocksDbExceptionWrapper(RocksDbStore store)
            {
                Contract.Requires(store != null);
                m_store = store;
            }

            [System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions] // allows catching exceptions from unmanaged code
            private void MarkExceptions(Action action)
            {
                Contract.Requires(action != null);

                try
                {
                    action.Invoke();
                }
                catch (Exception exception)
                {
                    // NOTE(jubayard): We can't use a different exception type here, because if we do, any exception 
                    // handling  inside of the .Use statement will receive that exception instead of the appropriate 
                    // one.
                    exception.Data[RocksDbInternalExceptionMarker] = true;
                    throw;
                }
            }

            [System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions] // allows catching exceptions from unmanaged code
            private T MarkExceptions<T>(Func<T> func)
            {
                Contract.Requires(func != null);

                try
                {
                    return func.Invoke();
                }
                catch (Exception exception)
                {
                    // NOTE(jubayard): We can't use a different exception type here, because if we do, any exception 
                    // handling  inside of the .Use statement will receive that exception instead of the appropriate 
                    // one.
                    exception.Data[RocksDbInternalExceptionMarker] = true;
                    throw;
                }
            }

            /// <inheritdoc />
            public void ApplyBatch(IEnumerable<KeyValuePair<string, string>> keyValuePairs, string columnFamilyName = null)
            {
                MarkExceptions(() => m_store.ApplyBatch(keyValuePairs, columnFamilyName));
            }

            /// <inheritdoc />
            public void ApplyBatch(IEnumerable<KeyValuePair<byte[], byte[]>> keyValuePairs, string columnFamilyName = null)
            {
                MarkExceptions(() => m_store.ApplyBatch(keyValuePairs, columnFamilyName));
            }

            /// <inheritdoc />
            public void CompactRange(string start, string limit, string columnFamilyName = null)
            {
                MarkExceptions(() => m_store.CompactRange(start, limit, columnFamilyName));
            }

            /// <inheritdoc />
            public void CompactRange(byte[] start, byte[] limit, string columnFamilyName = null)
            {
                MarkExceptions(() => m_store.CompactRange(start, limit, columnFamilyName));
            }

            /// <inheritdoc />
            public bool Contains(string key, string columnFamilyName = null)
            {
                return MarkExceptions(() => m_store.Contains(key, columnFamilyName));
            }

            /// <inheritdoc />
            public bool Contains(byte[] key, string columnFamilyName = null)
            {
                return MarkExceptions(() => m_store.Contains(key, columnFamilyName));
            }

            /// <inheritdoc />
            public IBuildXLKeyValueStore CreateSnapshot()
            {
                var snapshot = MarkExceptions(() => m_store.CreateSnapshot());

                if (snapshot is RocksDbStore rocksDbStore)
                {
                    return new RocksDbExceptionWrapper(rocksDbStore);
                }
                else
                {
                    return snapshot;
                }
            }

            /// <inheritdoc />
            public GarbageCollectResult GarbageCollect(Func<byte[], bool> canCollect, string primaryColumnFamilyName = null, IEnumerable<string> additionalColumnFamilyNames = null, CancellationToken cancellationToken = default, byte[] startValue = null)
            {
                return MarkExceptions(() => m_store.GarbageCollect(canCollect, primaryColumnFamilyName, additionalColumnFamilyNames, cancellationToken, startValue));
            }

            /// <inheritdoc />
            public GarbageCollectResult GarbageCollect(Func<byte[], byte[], bool> canCollect, string columnFamilyName = null, CancellationToken cancellationToken = default, byte[] startValue = null)
            {
                return MarkExceptions(() => m_store.GarbageCollect(canCollect, columnFamilyName, cancellationToken, startValue));
            }

            /// <inheritdoc />
            public GarbageCollectResult GarbageCollect(Func<string, bool> canCollect, string columnFamilyName = null, IEnumerable<string> additionalColumnFamilies = null, CancellationToken cancellationToken = default, string startValue = null)
            {
                return MarkExceptions(() => m_store.GarbageCollect(canCollect, columnFamilyName, additionalColumnFamilies, cancellationToken, startValue));
            }

            /// <inheritdoc />
            public GarbageCollectResult GarbageCollectByKeyValue(Func<Iterator, bool> canCollect, string primaryColumnFamilyName = null, IEnumerable<string> additionalColumnFamilyNames = null, CancellationToken cancellationToken = default, byte[] startValue = null)
            {
                return MarkExceptions(() => m_store.GarbageCollectByKeyValue(canCollect, primaryColumnFamilyName, additionalColumnFamilyNames, cancellationToken, startValue));
            }

            /// <inheritdoc />
            public string GetProperty(string propertyName, string columnFamilyName = null)
            {
                return MarkExceptions(() => m_store.GetProperty(propertyName, columnFamilyName));
            }

            /// <inheritdoc />
            /// <remarks>
            /// See remarks in the byte[] instantiation. 
            /// </remarks>
            public IEnumerable<KeyValuePair<string, string>> PrefixSearch(string prefix, string columnFamilyName = null)
            {
                return MarkExceptions(() => m_store.PrefixSearch(prefix, columnFamilyName));
            }

            /// <inheritdoc />
            /// <remarks>
            /// This method is problematic, because we can only catch exceptions that RocksDb may throw when creating 
            /// the iterator, nothing that could be generated while effectively iterating.
            /// 
            /// Most important exceptions should be caught by this anyways (i.e. DB corruption), but there's always a
            /// chance that something goes wrong as we iterate.
            /// </remarks>
            public IEnumerable<KeyValuePair<byte[], byte[]>> PrefixSearch(byte[] prefix, string columnFamilyName = null)
            {
                return MarkExceptions(() => m_store.PrefixSearch(prefix, columnFamilyName));
            }

            /// <inheritdoc />
            public void Put(string key, string value, string columnFamilyName = null)
            {
                MarkExceptions(() => m_store.Put(key, value, columnFamilyName));
            }

            /// <inheritdoc />
            public void Put(byte[] key, byte[] value, string columnFamilyName = null)
            {
                MarkExceptions(() => m_store.Put(key, value, columnFamilyName));
            }

            /// <inheritdoc />
            public void Remove(string key, string columnFamilyName = null)
            {
                MarkExceptions(() => m_store.Remove(key, columnFamilyName));
            }

            /// <inheritdoc />
            public void Remove(byte[] key, string columnFamilyName = null)
            {
                MarkExceptions(() => m_store.Remove(key, columnFamilyName));
            }

            /// <inheritdoc />
            public void RemoveBatch(IEnumerable<string> keys, IEnumerable<string> columnFamilyNames = null)
            {
                MarkExceptions(() => m_store.RemoveBatch(keys, columnFamilyNames));
            }

            /// <inheritdoc />
            public void RemoveBatch(IEnumerable<byte[]> keys, IEnumerable<string> columnFamilyNames = null)
            {
                MarkExceptions(() => m_store.RemoveBatch(keys, columnFamilyNames));
            }

            /// <inheritdoc />
            public void SaveCheckpoint(string targetDirectory)
            {
                MarkExceptions(() => m_store.SaveCheckpoint(targetDirectory));
            }

            /// <inheritdoc />
            public bool TryGetValue(string key, out string value, string columnFamilyName = null)
            {
                var output = MarkExceptions<(bool, string)>(() =>
                {
                    var result = m_store.TryGetValue(key, out var output_value, columnFamilyName);
                    return (result, output_value);
                });

                value = output.Item2;
                return output.Item1;
            }

            /// <inheritdoc />
            public bool TryGetValue(byte[] key, out byte[] value, string columnFamilyName = null)
            {
                var output = MarkExceptions<(bool, byte[])>(() =>
                {
                    var result = m_store.TryGetValue(key, out var output_value, columnFamilyName);
                    return (result, output_value);
                });

                value = output.Item2;
                return output.Item1;
            }

            /// <inheritdoc />
            public void Dispose()
            {
                MarkExceptions(() => m_store.Dispose());
            }
        }
    }
}
